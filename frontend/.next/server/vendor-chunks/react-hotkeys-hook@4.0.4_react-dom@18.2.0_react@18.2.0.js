"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/react-hotkeys-hook@4.0.4_react-dom@18.2.0_react@18.2.0";
exports.ids = ["vendor-chunks/react-hotkeys-hook@4.0.4_react-dom@18.2.0_react@18.2.0"];
exports.modules = {

/***/ "(ssr)/./node_modules/.pnpm/react-hotkeys-hook@4.0.4_react-dom@18.2.0_react@18.2.0/node_modules/react-hotkeys-hook/dist/react-hotkeys-hook.esm.js":
/*!**************************************************************************************************************************************************!*\
  !*** ./node_modules/.pnpm/react-hotkeys-hook@4.0.4_react-dom@18.2.0_react@18.2.0/node_modules/react-hotkeys-hook/dist/react-hotkeys-hook.esm.js ***!
  \**************************************************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   HotkeysProvider: () => (/* binding */ HotkeysProvider),\n/* harmony export */   isHotkeyPressed: () => (/* binding */ isHotkeyPressed),\n/* harmony export */   useHotkeys: () => (/* binding */ useHotkeys),\n/* harmony export */   useHotkeysContext: () => (/* binding */ useHotkeysContext)\n/* harmony export */ });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"(ssr)/./node_modules/.pnpm/next@14.0.4_react-dom@18.2.0_react@18.2.0/node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react/jsx-runtime */ \"(ssr)/./node_modules/.pnpm/next@14.0.4_react-dom@18.2.0_react@18.2.0/node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react-jsx-runtime.js\");\n/* harmony import */ var react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__);\n\n\nfunction _extends() {\n    _extends = Object.assign ? Object.assign.bind() : function(target) {\n        for(var i = 1; i < arguments.length; i++){\n            var source = arguments[i];\n            for(var key in source){\n                if (Object.prototype.hasOwnProperty.call(source, key)) {\n                    target[key] = source[key];\n                }\n            }\n        }\n        return target;\n    };\n    return _extends.apply(this, arguments);\n}\nfunction _unsupportedIterableToArray(o, minLen) {\n    if (!o) return;\n    if (typeof o === \"string\") return _arrayLikeToArray(o, minLen);\n    var n = Object.prototype.toString.call(o).slice(8, -1);\n    if (n === \"Object\" && o.constructor) n = o.constructor.name;\n    if (n === \"Map\" || n === \"Set\") return Array.from(o);\n    if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);\n}\nfunction _arrayLikeToArray(arr, len) {\n    if (len == null || len > arr.length) len = arr.length;\n    for(var i = 0, arr2 = new Array(len); i < len; i++)arr2[i] = arr[i];\n    return arr2;\n}\nfunction _createForOfIteratorHelperLoose(o, allowArrayLike) {\n    var it = typeof Symbol !== \"undefined\" && o[Symbol.iterator] || o[\"@@iterator\"];\n    if (it) return (it = it.call(o)).next.bind(it);\n    if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === \"number\") {\n        if (it) o = it;\n        var i = 0;\n        return function() {\n            if (i >= o.length) return {\n                done: true\n            };\n            return {\n                done: false,\n                value: o[i++]\n            };\n        };\n    }\n    throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n}\nvar reservedModifierKeywords = [\n    \"ctrl\",\n    \"shift\",\n    \"alt\",\n    \"meta\",\n    \"mod\"\n];\nvar mappedKeys = {\n    esc: \"escape\",\n    \"return\": \"enter\",\n    left: \"arrowleft\",\n    up: \"arrowup\",\n    right: \"arrowright\",\n    down: \"arrowdown\"\n};\nfunction parseKeysHookInput(keys, splitKey) {\n    if (splitKey === void 0) {\n        splitKey = \",\";\n    }\n    if (typeof keys === \"string\") {\n        return keys.split(splitKey);\n    }\n    return keys;\n}\nfunction parseHotkey(hotkey, combinationKey) {\n    if (combinationKey === void 0) {\n        combinationKey = \"+\";\n    }\n    var keys = hotkey.toLocaleLowerCase().split(combinationKey).map(function(k) {\n        return k.trim();\n    }).map(function(k) {\n        return mappedKeys[k] || k;\n    });\n    var modifiers = {\n        alt: keys.includes(\"alt\"),\n        ctrl: keys.includes(\"ctrl\"),\n        shift: keys.includes(\"shift\"),\n        meta: keys.includes(\"meta\"),\n        mod: keys.includes(\"mod\")\n    };\n    var singleCharKeys = keys.filter(function(k) {\n        return !reservedModifierKeywords.includes(k);\n    });\n    return _extends({}, modifiers, {\n        keys: singleCharKeys\n    });\n}\nfunction maybePreventDefault(e, hotkey, preventDefault) {\n    if (typeof preventDefault === \"function\" && preventDefault(e, hotkey) || preventDefault === true) {\n        e.preventDefault();\n    }\n}\nfunction isHotkeyEnabled(e, hotkey, enabled) {\n    if (typeof enabled === \"function\") {\n        return enabled(e, hotkey);\n    }\n    return enabled === true || enabled === undefined;\n}\nfunction isKeyboardEventTriggeredByInput(ev) {\n    return isHotkeyEnabledOnTag(ev, [\n        \"input\",\n        \"textarea\",\n        \"select\"\n    ]);\n}\nfunction isHotkeyEnabledOnTag(_ref, enabledOnTags) {\n    var target = _ref.target;\n    if (enabledOnTags === void 0) {\n        enabledOnTags = false;\n    }\n    var targetTagName = target && target.tagName;\n    if (enabledOnTags instanceof Array) {\n        return Boolean(targetTagName && enabledOnTags && enabledOnTags.some(function(tag) {\n            return tag.toLowerCase() === targetTagName.toLowerCase();\n        }));\n    }\n    return Boolean(targetTagName && enabledOnTags && enabledOnTags === true);\n}\nfunction isScopeActive(activeScopes, scopes) {\n    if (activeScopes.length === 0 && scopes) {\n        console.warn('A hotkey has the \"scopes\" option set, however no active scopes were found. If you want to use the global scopes feature, you need to wrap your app in a <HotkeysProvider>');\n        return true;\n    }\n    if (!scopes) {\n        return true;\n    }\n    return activeScopes.some(function(scope) {\n        return scopes.includes(scope);\n    }) || activeScopes.includes(\"*\");\n}\nvar isHotkeyMatchingKeyboardEvent = function isHotkeyMatchingKeyboardEvent(e, hotkey, pressedDownKeys) {\n    var alt = hotkey.alt, ctrl = hotkey.ctrl, meta = hotkey.meta, mod = hotkey.mod, shift = hotkey.shift, keys = hotkey.keys;\n    var altKey = e.altKey, ctrlKey = e.ctrlKey, metaKey = e.metaKey, shiftKey = e.shiftKey, pressedKeyUppercase = e.key, code = e.code;\n    var keyCode = code.toLowerCase().replace(\"key\", \"\");\n    var pressedKey = pressedKeyUppercase.toLowerCase();\n    if (altKey !== alt && pressedKey !== \"alt\") {\n        return false;\n    }\n    if (shiftKey !== shift && pressedKey !== \"shift\") {\n        return false;\n    }\n    // Mod is a special key name that is checking for meta on macOS and ctrl on other platforms\n    if (mod) {\n        if (!metaKey && !ctrlKey) {\n            return false;\n        }\n    } else {\n        if (metaKey !== meta && keyCode !== \"meta\") {\n            return false;\n        }\n        if (ctrlKey !== ctrl && keyCode !== \"ctrl\") {\n            return false;\n        }\n    }\n    // All modifiers are correct, now check the key\n    // If the key is set we check for the key\n    if (keys && keys.length === 1 && (keys.includes(pressedKey) || keys.includes(keyCode))) {\n        return true;\n    } else if (keys) {\n        // Check if all keys are present in pressedDownKeys set\n        return keys.every(function(key) {\n            return pressedDownKeys.has(key);\n        });\n    } else if (!keys) {\n        // If the key is not set, we only listen for modifiers, that check went alright, so we return true\n        return true;\n    }\n    // There is nothing that matches.\n    return false;\n};\nvar BoundHotkeysProxyProvider = /*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_0__.createContext)(undefined);\nvar useBoundHotkeysProxy = function useBoundHotkeysProxy() {\n    return (0,react__WEBPACK_IMPORTED_MODULE_0__.useContext)(BoundHotkeysProxyProvider);\n};\nfunction BoundHotkeysProxyProviderProvider(_ref) {\n    var addHotkey = _ref.addHotkey, removeHotkey = _ref.removeHotkey, children = _ref.children;\n    return /*#__PURE__*/ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(BoundHotkeysProxyProvider.Provider, {\n        value: {\n            addHotkey: addHotkey,\n            removeHotkey: removeHotkey\n        },\n        children: children\n    });\n}\nvar HotkeysContext = /*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_0__.createContext)({\n    hotkeys: [],\n    enabledScopes: [],\n    toggleScope: function toggleScope() {},\n    enableScope: function enableScope() {},\n    disableScope: function disableScope() {}\n});\nvar useHotkeysContext = function useHotkeysContext() {\n    return (0,react__WEBPACK_IMPORTED_MODULE_0__.useContext)(HotkeysContext);\n};\nvar HotkeysProvider = function HotkeysProvider(_ref) {\n    var _ref$initiallyActiveS = _ref.initiallyActiveScopes, initiallyActiveScopes = _ref$initiallyActiveS === void 0 ? [\n        \"*\"\n    ] : _ref$initiallyActiveS, children = _ref.children;\n    var _useState = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)((initiallyActiveScopes == null ? void 0 : initiallyActiveScopes.length) > 0 ? initiallyActiveScopes : [\n        \"*\"\n    ]), internalActiveScopes = _useState[0], setInternalActiveScopes = _useState[1];\n    var _useState2 = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)([]), boundHotkeys = _useState2[0], setBoundHotkeys = _useState2[1];\n    var isAllActive = (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(function() {\n        return internalActiveScopes.includes(\"*\");\n    }, [\n        internalActiveScopes\n    ]);\n    var enableScope = function enableScope(scope) {\n        if (isAllActive) {\n            setInternalActiveScopes([\n                scope\n            ]);\n        } else {\n            setInternalActiveScopes(Array.from(new Set([].concat(internalActiveScopes, [\n                scope\n            ]))));\n        }\n    };\n    var disableScope = function disableScope(scope) {\n        var scopes = internalActiveScopes.filter(function(s) {\n            return s !== scope;\n        });\n        if (scopes.length === 0) {\n            setInternalActiveScopes([\n                \"*\"\n            ]);\n        } else {\n            setInternalActiveScopes(scopes);\n        }\n    };\n    var toggleScope = function toggleScope(scope) {\n        if (internalActiveScopes.includes(scope)) {\n            disableScope(scope);\n        } else {\n            enableScope(scope);\n        }\n    };\n    var addBoundHotkey = function addBoundHotkey(hotkey) {\n        setBoundHotkeys([].concat(boundHotkeys, [\n            hotkey\n        ]));\n    };\n    var removeBoundHotkey = function removeBoundHotkey(hotkey) {\n        setBoundHotkeys(boundHotkeys.filter(function(h) {\n            return h.keys !== hotkey.keys;\n        }));\n    };\n    return /*#__PURE__*/ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(HotkeysContext.Provider, {\n        value: {\n            enabledScopes: internalActiveScopes,\n            hotkeys: boundHotkeys,\n            enableScope: enableScope,\n            disableScope: disableScope,\n            toggleScope: toggleScope\n        },\n        children: /*#__PURE__*/ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(BoundHotkeysProxyProviderProvider, {\n            addHotkey: addBoundHotkey,\n            removeHotkey: removeBoundHotkey,\n            children: children\n        })\n    });\n};\nfunction deepEqual(x, y) {\n    //@ts-ignore\n    return x && y && typeof x === \"object\" && typeof y === \"object\" ? Object.keys(x).length === Object.keys(y).length && Object.keys(x).reduce(function(isEqual, key) {\n        return isEqual && deepEqual(x[key], y[key]);\n    }, true) : x === y;\n}\nfunction useDeepEqualMemo(value) {\n    var ref = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(undefined);\n    if (!deepEqual(ref.current, value)) {\n        ref.current = value;\n    }\n    return ref.current;\n}\nvar stopPropagation = function stopPropagation(e) {\n    e.stopPropagation();\n    e.preventDefault();\n    e.stopImmediatePropagation();\n};\nvar useSafeLayoutEffect =  false ? 0 : react__WEBPACK_IMPORTED_MODULE_0__.useEffect;\nfunction useHotkeys(keys, callback, options, dependencies) {\n    var ref = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(null);\n    var _useRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(new Set()), pressedDownKeys = _useRef.current;\n    var _options = !(options instanceof Array) ? options : !(dependencies instanceof Array) ? dependencies : undefined;\n    var _deps = options instanceof Array ? options : dependencies instanceof Array ? dependencies : [];\n    var cb = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(callback, [].concat(_deps));\n    var memoisedOptions = useDeepEqualMemo(_options);\n    var _useHotkeysContext = useHotkeysContext(), enabledScopes = _useHotkeysContext.enabledScopes;\n    var proxy = useBoundHotkeysProxy();\n    useSafeLayoutEffect(function() {\n        if ((memoisedOptions == null ? void 0 : memoisedOptions.enabled) === false || !isScopeActive(enabledScopes, memoisedOptions == null ? void 0 : memoisedOptions.scopes)) {\n            return;\n        }\n        var listener = function listener(e) {\n            var _e$target;\n            if (isKeyboardEventTriggeredByInput(e) && !isHotkeyEnabledOnTag(e, memoisedOptions == null ? void 0 : memoisedOptions.enableOnFormTags)) {\n                return;\n            }\n            // TODO: SINCE THE EVENT IS NOW ATTACHED TO THE REF, THE ACTIVE ELEMENT CAN NEVER BE INSIDE THE REF. THE HOTKEY ONLY TRIGGERS IF THE\n            // REF IS THE ACTIVE ELEMENT. THIS IS A PROBLEM SINCE FOCUSED SUB COMPONENTS WONT TRIGGER THE HOTKEY.\n            if (ref.current !== null && document.activeElement !== ref.current && !ref.current.contains(document.activeElement)) {\n                stopPropagation(e);\n                return;\n            }\n            if ((_e$target = e.target) != null && _e$target.isContentEditable && !(memoisedOptions != null && memoisedOptions.enableOnContentEditable)) {\n                return;\n            }\n            parseKeysHookInput(keys, memoisedOptions == null ? void 0 : memoisedOptions.splitKey).forEach(function(key) {\n                var _hotkey$keys;\n                var hotkey = parseHotkey(key, memoisedOptions == null ? void 0 : memoisedOptions.combinationKey);\n                if (isHotkeyMatchingKeyboardEvent(e, hotkey, pressedDownKeys) || (_hotkey$keys = hotkey.keys) != null && _hotkey$keys.includes(\"*\")) {\n                    maybePreventDefault(e, hotkey, memoisedOptions == null ? void 0 : memoisedOptions.preventDefault);\n                    if (!isHotkeyEnabled(e, hotkey, memoisedOptions == null ? void 0 : memoisedOptions.enabled)) {\n                        stopPropagation(e);\n                        return;\n                    }\n                    cb(e, hotkey);\n                }\n            });\n        };\n        var handleKeyDown = function handleKeyDown(event) {\n            pressedDownKeys.add(event.key.toLowerCase());\n            if ((memoisedOptions == null ? void 0 : memoisedOptions.keydown) === undefined && (memoisedOptions == null ? void 0 : memoisedOptions.keyup) !== true || memoisedOptions != null && memoisedOptions.keydown) {\n                listener(event);\n            }\n        };\n        var handleKeyUp = function handleKeyUp(event) {\n            if (event.key.toLowerCase() !== \"meta\") {\n                pressedDownKeys[\"delete\"](event.key.toLowerCase());\n            } else {\n                // On macOS pressing down the meta key prevents triggering the keyup event for any other key https://stackoverflow.com/a/57153300/735226.\n                pressedDownKeys.clear();\n            }\n            if (memoisedOptions != null && memoisedOptions.keyup) {\n                listener(event);\n            }\n        };\n        // @ts-ignore\n        (ref.current || document).addEventListener(\"keyup\", handleKeyUp);\n        // @ts-ignore\n        (ref.current || document).addEventListener(\"keydown\", handleKeyDown);\n        if (proxy) {\n            parseKeysHookInput(keys, memoisedOptions == null ? void 0 : memoisedOptions.splitKey).forEach(function(key) {\n                return proxy.addHotkey(parseHotkey(key, memoisedOptions == null ? void 0 : memoisedOptions.combinationKey));\n            });\n        }\n        return function() {\n            // @ts-ignore\n            (ref.current || document).removeEventListener(\"keyup\", handleKeyUp);\n            // @ts-ignore\n            (ref.current || document).removeEventListener(\"keydown\", handleKeyDown);\n            if (proxy) {\n                parseKeysHookInput(keys, memoisedOptions == null ? void 0 : memoisedOptions.splitKey).forEach(function(key) {\n                    return proxy.removeHotkey(parseHotkey(key, memoisedOptions == null ? void 0 : memoisedOptions.combinationKey));\n                });\n            }\n        };\n    }, [\n        keys,\n        cb,\n        memoisedOptions,\n        enabledScopes\n    ]);\n    return ref;\n}\nvar currentlyPressedKeys = /*#__PURE__*/ new Set();\nfunction isHotkeyPressed(key, splitKey) {\n    if (splitKey === void 0) {\n        splitKey = \",\";\n    }\n    var hotkeyArray = Array.isArray(key) ? key : key.split(splitKey);\n    return hotkeyArray.every(function(hotkey) {\n        var parsedHotkey = parseHotkey(hotkey);\n        for(var _iterator = _createForOfIteratorHelperLoose(currentlyPressedKeys), _step; !(_step = _iterator()).done;){\n            var pressedHotkey = _step.value;\n            if (deepEqual(parsedHotkey, pressedHotkey)) {\n                return true;\n            }\n        }\n    });\n}\nfunction pushToCurrentlyPressedKeys(key) {\n    var hotkeyArray = Array.isArray(key) ? key : [\n        key\n    ];\n    hotkeyArray.forEach(function(hotkey) {\n        return currentlyPressedKeys.add(parseHotkey(hotkey));\n    });\n}\nfunction removeFromCurrentlyPressedKeys(key) {\n    var hotkeyArray = Array.isArray(key) ? key : [\n        key\n    ];\n    hotkeyArray.forEach(function(hotkey) {\n        var parsedHotkey = parseHotkey(hotkey);\n        for(var _iterator2 = _createForOfIteratorHelperLoose(currentlyPressedKeys), _step2; !(_step2 = _iterator2()).done;){\n            var _pressedHotkey$keys;\n            var pressedHotkey = _step2.value;\n            if ((_pressedHotkey$keys = pressedHotkey.keys) != null && _pressedHotkey$keys.every(function(key) {\n                var _parsedHotkey$keys;\n                return (_parsedHotkey$keys = parsedHotkey.keys) == null ? void 0 : _parsedHotkey$keys.includes(key);\n            })) {\n                currentlyPressedKeys[\"delete\"](pressedHotkey);\n            }\n        }\n    });\n}\n(function() {\n    if (false) {}\n})();\n //# sourceMappingURL=react-hotkeys-hook.esm.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvLnBucG0vcmVhY3QtaG90a2V5cy1ob29rQDQuMC40X3JlYWN0LWRvbUAxOC4yLjBfcmVhY3RAMTguMi4wL25vZGVfbW9kdWxlcy9yZWFjdC1ob3RrZXlzLWhvb2svZGlzdC9yZWFjdC1ob3RrZXlzLWhvb2suZXNtLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7O0FBQXNIO0FBQzlFO0FBRXhDLFNBQVNTO0lBQ1BBLFdBQVdDLE9BQU9DLE1BQU0sR0FBR0QsT0FBT0MsTUFBTSxDQUFDQyxJQUFJLEtBQUssU0FBVUMsTUFBTTtRQUNoRSxJQUFLLElBQUlDLElBQUksR0FBR0EsSUFBSUMsVUFBVUMsTUFBTSxFQUFFRixJQUFLO1lBQ3pDLElBQUlHLFNBQVNGLFNBQVMsQ0FBQ0QsRUFBRTtZQUN6QixJQUFLLElBQUlJLE9BQU9ELE9BQVE7Z0JBQ3RCLElBQUlQLE9BQU9TLFNBQVMsQ0FBQ0MsY0FBYyxDQUFDQyxJQUFJLENBQUNKLFFBQVFDLE1BQU07b0JBQ3JETCxNQUFNLENBQUNLLElBQUksR0FBR0QsTUFBTSxDQUFDQyxJQUFJO2dCQUMzQjtZQUNGO1FBQ0Y7UUFDQSxPQUFPTDtJQUNUO0lBQ0EsT0FBT0osU0FBU2EsS0FBSyxDQUFDLElBQUksRUFBRVA7QUFDOUI7QUFDQSxTQUFTUSw0QkFBNEJDLENBQUMsRUFBRUMsTUFBTTtJQUM1QyxJQUFJLENBQUNELEdBQUc7SUFDUixJQUFJLE9BQU9BLE1BQU0sVUFBVSxPQUFPRSxrQkFBa0JGLEdBQUdDO0lBQ3ZELElBQUlFLElBQUlqQixPQUFPUyxTQUFTLENBQUNTLFFBQVEsQ0FBQ1AsSUFBSSxDQUFDRyxHQUFHSyxLQUFLLENBQUMsR0FBRyxDQUFDO0lBQ3BELElBQUlGLE1BQU0sWUFBWUgsRUFBRU0sV0FBVyxFQUFFSCxJQUFJSCxFQUFFTSxXQUFXLENBQUNDLElBQUk7SUFDM0QsSUFBSUosTUFBTSxTQUFTQSxNQUFNLE9BQU8sT0FBT0ssTUFBTUMsSUFBSSxDQUFDVDtJQUNs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eEosTUFBTVksT0FBTyxDQUFDMUIsT0FBT0EsTUFBTTtRQUFDQTtLQUFJO0lBQ2xEc0ssWUFBWWIsT0FBTyxDQUFDLFNBQVUvRyxNQUFNO1FBQ2xDLElBQUk2SCxlQUFlOUgsWUFBWUM7UUFDL0IsSUFBSyxJQUFJbUksYUFBYXpKLGdDQUFnQ2dKLHVCQUF1QlUsUUFBUSxDQUFDLENBQUNBLFNBQVNELFlBQVcsRUFBR2xKLElBQUksRUFBRztZQUNuSCxJQUFJb0o7WUFDSixJQUFJTCxnQkFBZ0JJLE9BQU9sSixLQUFLO1lBQ2hDLElBQUksQ0FBQ21KLHNCQUFzQkwsY0FBY3BJLElBQUksS0FBSyxRQUFReUksb0JBQW9CcEYsS0FBSyxDQUFDLFNBQVUzRixHQUFHO2dCQUMvRixJQUFJZ0w7Z0JBQ0osT0FBTyxDQUFDQSxxQkFBcUJULGFBQWFqSSxJQUFJLEtBQUssT0FBTyxLQUFLLElBQUkwSSxtQkFBbUI5SCxRQUFRLENBQUNsRDtZQUNqRyxJQUFJO2dCQUNGb0ssb0JBQW9CLENBQUMsU0FBUyxDQUFDTTtZQUNqQztRQUNGO0lBQ0Y7QUFDRjtBQUNDO0lBQ0MsSUFBSSxLQUFrQixFQUFhLEVBU2xDO0FBQ0g7QUFFMkUsQ0FDM0Usa0RBQWtEIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vdGlwb2hpei8uL25vZGVfbW9kdWxlcy8ucG5wbS9yZWFjdC1ob3RrZXlzLWhvb2tANC4wLjRfcmVhY3QtZG9tQDE4LjIuMF9yZWFjdEAxOC4yLjAvbm9kZV9tb2R1bGVzL3JlYWN0LWhvdGtleXMtaG9vay9kaXN0L3JlYWN0LWhvdGtleXMtaG9vay5lc20uanM/OTg5YiJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyB1c2VDb250ZXh0LCBjcmVhdGVDb250ZXh0LCB1c2VTdGF0ZSwgdXNlTWVtbywgdXNlUmVmLCB1c2VDYWxsYmFjaywgdXNlTGF5b3V0RWZmZWN0LCB1c2VFZmZlY3QgfSBmcm9tICdyZWFjdCc7XG5pbXBvcnQgeyBqc3ggfSBmcm9tICdyZWFjdC9qc3gtcnVudGltZSc7XG5cbmZ1bmN0aW9uIF9leHRlbmRzKCkge1xuICBfZXh0ZW5kcyA9IE9iamVjdC5hc3NpZ24gPyBPYmplY3QuYXNzaWduLmJpbmQoKSA6IGZ1bmN0aW9uICh0YXJnZXQpIHtcbiAgICBmb3IgKHZhciBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIHNvdXJjZSA9IGFyZ3VtZW50c1tpXTtcbiAgICAgIGZvciAodmFyIGtleSBpbiBzb3VyY2UpIHtcbiAgICAgICAgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChzb3VyY2UsIGtleSkpIHtcbiAgICAgICAgICB0YXJnZXRba2V5XSA9IHNvdXJjZVtrZXldO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiB0YXJnZXQ7XG4gIH07XG4gIHJldHVybiBfZXh0ZW5kcy5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xufVxuZnVuY3Rpb24gX3Vuc3VwcG9ydGVkSXRlcmFibGVUb0FycmF5KG8sIG1pbkxlbikge1xuICBpZiAoIW8pIHJldHVybjtcbiAgaWYgKHR5cGVvZiBvID09PSBcInN0cmluZ1wiKSByZXR1cm4gX2FycmF5TGlrZVRvQXJyYXkobywgbWluTGVuKTtcbiAgdmFyIG4gPSBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwobykuc2xpY2UoOCwgLTEpO1xuICBpZiAobiA9PT0gXCJPYmplY3RcIiAmJiBvLmNvbnN0cnVjdG9yKSBuID0gby5jb25zdHJ1Y3Rvci5uYW1lO1xuICBpZiAobiA9PT0gXCJNYXBcIiB8fCBuID09PSBcIlNldFwiKSByZXR1cm4gQXJyYXkuZnJvbShvKTtcbiAgaWYgKG4gPT09IFwiQXJndW1lbnRzXCIgfHwgL14oPzpVaXxJKW50KD86OHwxNnwzMikoPzpDbGFtcGVkKT9BcnJheSQvLnRlc3QobikpIHJldHVybiBfYXJyYXlMaWtlVG9BcnJheShvLCBtaW5MZW4pO1xufVxuZnVuY3Rpb24gX2FycmF5TGlrZVRvQXJyYXkoYXJyLCBsZW4pIHtcbiAgaWYgKGxlbiA9PSBudWxsIHx8IGxlbiA+IGFyci5sZW5ndGgpIGxlbiA9IGFyci5sZW5ndGg7XG4gIGZvciAodmFyIGkgPSAwLCBhcnIyID0gbmV3IEFycmF5KGxlbik7IGkgPCBsZW47IGkrKykgYXJyMltpXSA9IGFycltpXTtcbiAgcmV0dXJuIGFycjI7XG59XG5mdW5jdGlvbiBfY3JlYXRlRm9yT2ZJdGVyYXRvckhlbHBlckxvb3NlKG8sIGFsbG93QXJyYXlMaWtlKSB7XG4gIHZhciBpdCA9IHR5cGVvZiBTeW1ib2wgIT09IFwidW5kZWZpbmVkXCIgJiYgb1tTeW1ib2wuaXRlcmF0b3JdIHx8IG9bXCJAQGl0ZXJhdG9yXCJdO1xuICBpZiAoaXQpIHJldHVybiAoaXQgPSBpdC5jYWxsKG8pKS5uZXh0LmJpbmQoaXQpO1xuICBpZiAoQXJyYXkuaXNBcnJheShvKSB8fCAoaXQgPSBfdW5zdXBwb3J0ZWRJdGVyYWJsZVRvQXJyYXkobykpIHx8IGFsbG93QXJyYXlMaWtlICYmIG8gJiYgdHlwZW9mIG8ubGVuZ3RoID09PSBcIm51bWJlclwiKSB7XG4gICAgaWYgKGl0KSBvID0gaXQ7XG4gICAgdmFyIGkgPSAwO1xuICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICBpZiAoaSA+PSBvLmxlbmd0aCkgcmV0dXJuIHtcbiAgICAgICAgZG9uZTogdHJ1ZVxuICAgICAgfTtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIGRvbmU6IGZhbHNlLFxuICAgICAgICB2YWx1ZTogb1tpKytdXG4gICAgICB9O1xuICAgIH07XG4gIH1cbiAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkludmFsaWQgYXR0ZW1wdCB0byBpdGVyYXRlIG5vbi1pdGVyYWJsZSBpbnN0YW5jZS5cXG5JbiBvcmRlciB0byBiZSBpdGVyYWJsZSwgbm9uLWFycmF5IG9iamVjdHMgbXVzdCBoYXZlIGEgW1N5bWJvbC5pdGVyYXRvcl0oKSBtZXRob2QuXCIpO1xufVxuXG52YXIgcmVzZXJ2ZWRNb2RpZmllcktleXdvcmRzID0gWydjdHJsJywgJ3NoaWZ0JywgJ2FsdCcsICdtZXRhJywgJ21vZCddO1xudmFyIG1hcHBlZEtleXMgPSB7XG4gIGVzYzogJ2VzY2FwZScsXG4gIFwicmV0dXJuXCI6ICdlbnRlcicsXG4gIGxlZnQ6ICdhcnJvd2xlZnQnLFxuICB1cDogJ2Fycm93dXAnLFxuICByaWdodDogJ2Fycm93cmlnaHQnLFxuICBkb3duOiAnYXJyb3dkb3duJ1xufTtcbmZ1bmN0aW9uIHBhcnNlS2V5c0hvb2tJbnB1dChrZXlzLCBzcGxpdEtleSkge1xuICBpZiAoc3BsaXRLZXkgPT09IHZvaWQgMCkge1xuICAgIHNwbGl0S2V5ID0gJywnO1xuICB9XG4gIGlmICh0eXBlb2Yga2V5cyA9PT0gJ3N0cmluZycpIHtcbiAgICByZXR1cm4ga2V5cy5zcGxpdChzcGxpdEtleSk7XG4gIH1cbiAgcmV0dXJuIGtleXM7XG59XG5mdW5jdGlvbiBwYXJzZUhvdGtleShob3RrZXksIGNvbWJpbmF0aW9uS2V5KSB7XG4gIGlmIChjb21iaW5hdGlvbktleSA9PT0gdm9pZCAwKSB7XG4gICAgY29tYmluYXRpb25LZXkgPSAnKyc7XG4gIH1cbiAgdmFyIGtleXMgPSBob3RrZXkudG9Mb2NhbGVMb3dlckNhc2UoKS5zcGxpdChjb21iaW5hdGlvbktleSkubWFwKGZ1bmN0aW9uIChrKSB7XG4gICAgcmV0dXJuIGsudHJpbSgpO1xuICB9KS5tYXAoZnVuY3Rpb24gKGspIHtcbiAgICByZXR1cm4gbWFwcGVkS2V5c1trXSB8fCBrO1xuICB9KTtcbiAgdmFyIG1vZGlmaWVycyA9IHtcbiAgICBhbHQ6IGtleXMuaW5jbHVkZXMoJ2FsdCcpLFxuICAgIGN0cmw6IGtleXMuaW5jbHVkZXMoJ2N0cmwnKSxcbiAgICBzaGlmdDoga2V5cy5pbmNsdWRlcygnc2hpZnQnKSxcbiAgICBtZXRhOiBrZXlzLmluY2x1ZGVzKCdtZXRhJyksXG4gICAgbW9kOiBrZXlzLmluY2x1ZGVzKCdtb2QnKVxuICB9O1xuICB2YXIgc2luZ2xlQ2hhcktleXMgPSBrZXlzLmZpbHRlcihmdW5jdGlvbiAoaykge1xuICAgIHJldHVybiAhcmVzZXJ2ZWRNb2RpZmllcktleXdvcmRzLmluY2x1ZGVzKGspO1xuICB9KTtcbiAgcmV0dXJuIF9leHRlbmRzKHt9LCBtb2RpZmllcnMsIHtcbiAgICBrZXlzOiBzaW5nbGVDaGFyS2V5c1xuICB9KTtcbn1cblxuZnVuY3Rpb24gbWF5YmVQcmV2ZW50RGVmYXVsdChlLCBob3RrZXksIHByZXZlbnREZWZhdWx0KSB7XG4gIGlmICh0eXBlb2YgcHJldmVudERlZmF1bHQgPT09ICdmdW5jdGlvbicgJiYgcHJldmVudERlZmF1bHQoZSwgaG90a2V5KSB8fCBwcmV2ZW50RGVmYXVsdCA9PT0gdHJ1ZSkge1xuICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgfVxufVxuZnVuY3Rpb24gaXNIb3RrZXlFbmFibGVkKGUsIGhvdGtleSwgZW5hYmxlZCkge1xuICBpZiAodHlwZW9mIGVuYWJsZWQgPT09ICdmdW5jdGlvbicpIHtcbiAgICByZXR1cm4gZW5hYmxlZChlLCBob3RrZXkpO1xuICB9XG4gIHJldHVybiBlbmFibGVkID09PSB0cnVlIHx8IGVuYWJsZWQgPT09IHVuZGVmaW5lZDtcbn1cbmZ1bmN0aW9uIGlzS2V5Ym9hcmRFdmVudFRyaWdnZXJlZEJ5SW5wdXQoZXYpIHtcbiAgcmV0dXJuIGlzSG90a2V5RW5hYmxlZE9uVGFnKGV2LCBbJ2lucHV0JywgJ3RleHRhcmVhJywgJ3NlbGVjdCddKTtcbn1cbmZ1bmN0aW9uIGlzSG90a2V5RW5hYmxlZE9uVGFnKF9yZWYsIGVuYWJsZWRPblRhZ3MpIHtcbiAgdmFyIHRhcmdldCA9IF9yZWYudGFyZ2V0O1xuICBpZiAoZW5hYmxlZE9uVGFncyA9PT0gdm9pZCAwKSB7XG4gICAgZW5hYmxlZE9uVGFncyA9IGZhbHNlO1xuICB9XG4gIHZhciB0YXJnZXRUYWdOYW1lID0gdGFyZ2V0ICYmIHRhcmdldC50YWdOYW1lO1xuICBpZiAoZW5hYmxlZE9uVGFncyBpbnN0YW5jZW9mIEFycmF5KSB7XG4gICAgcmV0dXJuIEJvb2xlYW4odGFyZ2V0VGFnTmFtZSAmJiBlbmFibGVkT25UYWdzICYmIGVuYWJsZWRPblRhZ3Muc29tZShmdW5jdGlvbiAodGFnKSB7XG4gICAgICByZXR1cm4gdGFnLnRvTG93ZXJDYXNlKCkgPT09IHRhcmdldFRhZ05hbWUudG9Mb3dlckNhc2UoKTtcbiAgICB9KSk7XG4gIH1cbiAgcmV0dXJuIEJvb2xlYW4odGFyZ2V0VGFnTmFtZSAmJiBlbmFibGVkT25UYWdzICYmIGVuYWJsZWRPblRhZ3MgPT09IHRydWUpO1xufVxuZnVuY3Rpb24gaXNTY29wZUFjdGl2ZShhY3RpdmVTY29wZXMsIHNjb3Blcykge1xuICBpZiAoYWN0aXZlU2NvcGVzLmxlbmd0aCA9PT0gMCAmJiBzY29wZXMpIHtcbiAgICBjb25zb2xlLndhcm4oJ0EgaG90a2V5IGhhcyB0aGUgXCJzY29wZXNcIiBvcHRpb24gc2V0LCBob3dldmVyIG5vIGFjdGl2ZSBzY29wZXMgd2VyZSBmb3VuZC4gSWYgeW91IHdhbnQgdG8gdXNlIHRoZSBnbG9iYWwgc2NvcGVzIGZlYXR1cmUsIHlvdSBuZWVkIHRvIHdyYXAgeW91ciBhcHAgaW4gYSA8SG90a2V5c1Byb3ZpZGVyPicpO1xuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIGlmICghc2NvcGVzKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgcmV0dXJuIGFjdGl2ZVNjb3Blcy5zb21lKGZ1bmN0aW9uIChzY29wZSkge1xuICAgIHJldHVybiBzY29wZXMuaW5jbHVkZXMoc2NvcGUpO1xuICB9KSB8fCBhY3RpdmVTY29wZXMuaW5jbHVkZXMoJyonKTtcbn1cbnZhciBpc0hvdGtleU1hdGNoaW5nS2V5Ym9hcmRFdmVudCA9IGZ1bmN0aW9uIGlzSG90a2V5TWF0Y2hpbmdLZXlib2FyZEV2ZW50KGUsIGhvdGtleSwgcHJlc3NlZERvd25LZXlzKSB7XG4gIHZhciBhbHQgPSBob3RrZXkuYWx0LFxuICAgIGN0cmwgPSBob3RrZXkuY3RybCxcbiAgICBtZXRhID0gaG90a2V5Lm1ldGEsXG4gICAgbW9kID0gaG90a2V5Lm1vZCxcbiAgICBzaGlmdCA9IGhvdGtleS5zaGlmdCxcbiAgICBrZXlzID0gaG90a2V5LmtleXM7XG4gIHZhciBhbHRLZXkgPSBlLmFsdEtleSxcbiAgICBjdHJsS2V5ID0gZS5jdHJsS2V5LFxuICAgIG1ldGFLZXkgPSBlLm1ldGFLZXksXG4gICAgc2hpZnRLZXkgPSBlLnNoaWZ0S2V5LFxuICAgIHByZXNzZWRLZXlVcHBlcmNhc2UgPSBlLmtleSxcbiAgICBjb2RlID0gZS5jb2RlO1xuICB2YXIga2V5Q29kZSA9IGNvZGUudG9Mb3dlckNhc2UoKS5yZXBsYWNlKCdrZXknLCAnJyk7XG4gIHZhciBwcmVzc2VkS2V5ID0gcHJlc3NlZEtleVVwcGVyY2FzZS50b0xvd2VyQ2FzZSgpO1xuICBpZiAoYWx0S2V5ICE9PSBhbHQgJiYgcHJlc3NlZEtleSAhPT0gJ2FsdCcpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgaWYgKHNoaWZ0S2V5ICE9PSBzaGlmdCAmJiBwcmVzc2VkS2V5ICE9PSAnc2hpZnQnKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIC8vIE1vZCBpcyBhIHNwZWNpYWwga2V5IG5hbWUgdGhhdCBpcyBjaGVja2luZyBmb3IgbWV0YSBvbiBtYWNPUyBhbmQgY3RybCBvbiBvdGhlciBwbGF0Zm9ybXNcbiAgaWYgKG1vZCkge1xuICAgIGlmICghbWV0YUtleSAmJiAhY3RybEtleSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBpZiAobWV0YUtleSAhPT0gbWV0YSAmJiBrZXlDb2RlICE9PSAnbWV0YScpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgaWYgKGN0cmxLZXkgIT09IGN0cmwgJiYga2V5Q29kZSAhPT0gJ2N0cmwnKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9XG4gIC8vIEFsbCBtb2RpZmllcnMgYXJlIGNvcnJlY3QsIG5vdyBjaGVjayB0aGUga2V5XG4gIC8vIElmIHRoZSBrZXkgaXMgc2V0IHdlIGNoZWNrIGZvciB0aGUga2V5XG4gIGlmIChrZXlzICYmIGtleXMubGVuZ3RoID09PSAxICYmIChrZXlzLmluY2x1ZGVzKHByZXNzZWRLZXkpIHx8IGtleXMuaW5jbHVkZXMoa2V5Q29kZSkpKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH0gZWxzZSBpZiAoa2V5cykge1xuICAgIC8vIENoZWNrIGlmIGFsbCBrZXlzIGFyZSBwcmVzZW50IGluIHByZXNzZWREb3duS2V5cyBzZXRcbiAgICByZXR1cm4ga2V5cy5ldmVyeShmdW5jdGlvbiAoa2V5KSB7XG4gICAgICByZXR1cm4gcHJlc3NlZERvd25LZXlzLmhhcyhrZXkpO1xuICAgIH0pO1xuICB9IGVsc2UgaWYgKCFrZXlzKSB7XG4gICAgLy8gSWYgdGhlIGtleSBpcyBub3Qgc2V0LCB3ZSBvbmx5IGxpc3RlbiBmb3IgbW9kaWZpZXJzLCB0aGF0IGNoZWNrIHdlbnQgYWxyaWdodCwgc28gd2UgcmV0dXJuIHRydWVcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICAvLyBUaGVyZSBpcyBub3RoaW5nIHRoYXQgbWF0Y2hlcy5cbiAgcmV0dXJuIGZhbHNlO1xufTtcblxudmFyIEJvdW5kSG90a2V5c1Byb3h5UHJvdmlkZXIgPSAvKiNfX1BVUkVfXyovY3JlYXRlQ29udGV4dCh1bmRlZmluZWQpO1xudmFyIHVzZUJvdW5kSG90a2V5c1Byb3h5ID0gZnVuY3Rpb24gdXNlQm91bmRIb3RrZXlzUHJveHkoKSB7XG4gIHJldHVybiB1c2VDb250ZXh0KEJvdW5kSG90a2V5c1Byb3h5UHJvdmlkZXIpO1xufTtcbmZ1bmN0aW9uIEJvdW5kSG90a2V5c1Byb3h5UHJvdmlkZXJQcm92aWRlcihfcmVmKSB7XG4gIHZhciBhZGRIb3RrZXkgPSBfcmVmLmFkZEhvdGtleSxcbiAgICByZW1vdmVIb3RrZXkgPSBfcmVmLnJlbW92ZUhvdGtleSxcbiAgICBjaGlsZHJlbiA9IF9yZWYuY2hpbGRyZW47XG4gIHJldHVybiAvKiNfX1BVUkVfXyovanN4KEJvdW5kSG90a2V5c1Byb3h5UHJvdmlkZXIuUHJvdmlkZXIsIHtcbiAgICB2YWx1ZToge1xuICAgICAgYWRkSG90a2V5OiBhZGRIb3RrZXksXG4gICAgICByZW1vdmVIb3RrZXk6IHJlbW92ZUhvdGtleVxuICAgIH0sXG4gICAgY2hpbGRyZW46IGNoaWxkcmVuXG4gIH0pO1xufVxuXG52YXIgSG90a2V5c0NvbnRleHQgPSAvKiNfX1BVUkVfXyovY3JlYXRlQ29udGV4dCh7XG4gIGhvdGtleXM6IFtdLFxuICBlbmFibGVkU2NvcGVzOiBbXSxcbiAgdG9nZ2xlU2NvcGU6IGZ1bmN0aW9uIHRvZ2dsZVNjb3BlKCkge30sXG4gIGVuYWJsZVNjb3BlOiBmdW5jdGlvbiBlbmFibGVTY29wZSgpIHt9LFxuICBkaXNhYmxlU2NvcGU6IGZ1bmN0aW9uIGRpc2FibGVTY29wZSgpIHt9XG59KTtcbnZhciB1c2VIb3RrZXlzQ29udGV4dCA9IGZ1bmN0aW9uIHVzZUhvdGtleXNDb250ZXh0KCkge1xuICByZXR1cm4gdXNlQ29udGV4dChIb3RrZXlzQ29udGV4dCk7XG59O1xudmFyIEhvdGtleXNQcm92aWRlciA9IGZ1bmN0aW9uIEhvdGtleXNQcm92aWRlcihfcmVmKSB7XG4gIHZhciBfcmVmJGluaXRpYWxseUFjdGl2ZVMgPSBfcmVmLmluaXRpYWxseUFjdGl2ZVNjb3BlcyxcbiAgICBpbml0aWFsbHlBY3RpdmVTY29wZXMgPSBfcmVmJGluaXRpYWxseUFjdGl2ZVMgPT09IHZvaWQgMCA/IFsnKiddIDogX3JlZiRpbml0aWFsbHlBY3RpdmVTLFxuICAgIGNoaWxkcmVuID0gX3JlZi5jaGlsZHJlbjtcbiAgdmFyIF91c2VTdGF0ZSA9IHVzZVN0YXRlKChpbml0aWFsbHlBY3RpdmVTY29wZXMgPT0gbnVsbCA/IHZvaWQgMCA6IGluaXRpYWxseUFjdGl2ZVNjb3Blcy5sZW5ndGgpID4gMCA/IGluaXRpYWxseUFjdGl2ZVNjb3BlcyA6IFsnKiddKSxcbiAgICBpbnRlcm5hbEFjdGl2ZVNjb3BlcyA9IF91c2VTdGF0ZVswXSxcbiAgICBzZXRJbnRlcm5hbEFjdGl2ZVNjb3BlcyA9IF91c2VTdGF0ZVsxXTtcbiAgdmFyIF91c2VTdGF0ZTIgPSB1c2VTdGF0ZShbXSksXG4gICAgYm91bmRIb3RrZXlzID0gX3VzZVN0YXRlMlswXSxcbiAgICBzZXRCb3VuZEhvdGtleXMgPSBfdXNlU3RhdGUyWzFdO1xuICB2YXIgaXNBbGxBY3RpdmUgPSB1c2VNZW1vKGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gaW50ZXJuYWxBY3RpdmVTY29wZXMuaW5jbHVkZXMoJyonKTtcbiAgfSwgW2ludGVybmFsQWN0aXZlU2NvcGVzXSk7XG4gIHZhciBlbmFibGVTY29wZSA9IGZ1bmN0aW9uIGVuYWJsZVNjb3BlKHNjb3BlKSB7XG4gICAgaWYgKGlzQWxsQWN0aXZlKSB7XG4gICAgICBzZXRJbnRlcm5hbEFjdGl2ZVNjb3Blcyhbc2NvcGVdKTtcbiAgICB9IGVsc2Uge1xuICAgICAgc2V0SW50ZXJuYWxBY3RpdmVTY29wZXMoQXJyYXkuZnJvbShuZXcgU2V0KFtdLmNvbmNhdChpbnRlcm5hbEFjdGl2ZVNjb3BlcywgW3Njb3BlXSkpKSk7XG4gICAgfVxuICB9O1xuICB2YXIgZGlzYWJsZVNjb3BlID0gZnVuY3Rpb24gZGlzYWJsZVNjb3BlKHNjb3BlKSB7XG4gICAgdmFyIHNjb3BlcyA9IGludGVybmFsQWN0aXZlU2NvcGVzLmZpbHRlcihmdW5jdGlvbiAocykge1xuICAgICAgcmV0dXJuIHMgIT09IHNjb3BlO1xuICAgIH0pO1xuICAgIGlmIChzY29wZXMubGVuZ3RoID09PSAwKSB7XG4gICAgICBzZXRJbnRlcm5hbEFjdGl2ZVNjb3BlcyhbJyonXSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHNldEludGVybmFsQWN0aXZlU2NvcGVzKHNjb3Blcyk7XG4gICAgfVxuICB9O1xuICB2YXIgdG9nZ2xlU2NvcGUgPSBmdW5jdGlvbiB0b2dnbGVTY29wZShzY29wZSkge1xuICAgIGlmIChpbnRlcm5hbEFjdGl2ZVNjb3Blcy5pbmNsdWRlcyhzY29wZSkpIHtcbiAgICAgIGRpc2FibGVTY29wZShzY29wZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGVuYWJsZVNjb3BlKHNjb3BlKTtcbiAgICB9XG4gIH07XG4gIHZhciBhZGRCb3VuZEhvdGtleSA9IGZ1bmN0aW9uIGFkZEJvdW5kSG90a2V5KGhvdGtleSkge1xuICAgIHNldEJvdW5kSG90a2V5cyhbXS5jb25jYXQoYm91bmRIb3RrZXlzLCBbaG90a2V5XSkpO1xuICB9O1xuICB2YXIgcmVtb3ZlQm91bmRIb3RrZXkgPSBmdW5jdGlvbiByZW1vdmVCb3VuZEhvdGtleShob3RrZXkpIHtcbiAgICBzZXRCb3VuZEhvdGtleXMoYm91bmRIb3RrZXlzLmZpbHRlcihmdW5jdGlvbiAoaCkge1xuICAgICAgcmV0dXJuIGgua2V5cyAhPT0gaG90a2V5LmtleXM7XG4gICAgfSkpO1xuICB9O1xuICByZXR1cm4gLyojX19QVVJFX18qL2pzeChIb3RrZXlzQ29udGV4dC5Qcm92aWRlciwge1xuICAgIHZhbHVlOiB7XG4gICAgICBlbmFibGVkU2NvcGVzOiBpbnRlcm5hbEFjdGl2ZVNjb3BlcyxcbiAgICAgIGhvdGtleXM6IGJvdW5kSG90a2V5cyxcbiAgICAgIGVuYWJsZVNjb3BlOiBlbmFibGVTY29wZSxcbiAgICAgIGRpc2FibGVTY29wZTogZGlzYWJsZVNjb3BlLFxuICAgICAgdG9nZ2xlU2NvcGU6IHRvZ2dsZVNjb3BlXG4gICAgfSxcbiAgICBjaGlsZHJlbjogLyojX19QVVJFX18qL2pzeChCb3VuZEhvdGtleXNQcm94eVByb3ZpZGVyUHJvdmlkZXIsIHtcbiAgICAgIGFkZEhvdGtleTogYWRkQm91bmRIb3RrZXksXG4gICAgICByZW1vdmVIb3RrZXk6IHJlbW92ZUJvdW5kSG90a2V5LFxuICAgICAgY2hpbGRyZW46IGNoaWxkcmVuXG4gICAgfSlcbiAgfSk7XG59O1xuXG5mdW5jdGlvbiBkZWVwRXF1YWwoeCwgeSkge1xuICAvL0B0cy1pZ25vcmVcbiAgcmV0dXJuIHggJiYgeSAmJiB0eXBlb2YgeCA9PT0gJ29iamVjdCcgJiYgdHlwZW9mIHkgPT09ICdvYmplY3QnXG4gIC8vQHRzLWlnbm9yZVxuICA/IE9iamVjdC5rZXlzKHgpLmxlbmd0aCA9PT0gT2JqZWN0LmtleXMoeSkubGVuZ3RoICYmIE9iamVjdC5rZXlzKHgpLnJlZHVjZShmdW5jdGlvbiAoaXNFcXVhbCwga2V5KSB7XG4gICAgcmV0dXJuIGlzRXF1YWwgJiYgZGVlcEVxdWFsKHhba2V5XSwgeVtrZXldKTtcbiAgfSwgdHJ1ZSkgOiB4ID09PSB5O1xufVxuXG5mdW5jdGlvbiB1c2VEZWVwRXF1YWxNZW1vKHZhbHVlKSB7XG4gIHZhciByZWYgPSB1c2VSZWYodW5kZWZpbmVkKTtcbiAgaWYgKCFkZWVwRXF1YWwocmVmLmN1cnJlbnQsIHZhbHVlKSkge1xuICAgIHJlZi5jdXJyZW50ID0gdmFsdWU7XG4gIH1cbiAgcmV0dXJuIHJlZi5jdXJyZW50O1xufVxuXG52YXIgc3RvcFByb3BhZ2F0aW9uID0gZnVuY3Rpb24gc3RvcFByb3BhZ2F0aW9uKGUpIHtcbiAgZS5zdG9wUHJvcGFnYXRpb24oKTtcbiAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICBlLnN0b3BJbW1lZGlhdGVQcm9wYWdhdGlvbigpO1xufTtcbnZhciB1c2VTYWZlTGF5b3V0RWZmZWN0ID0gdHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgPyB1c2VMYXlvdXRFZmZlY3QgOiB1c2VFZmZlY3Q7XG5mdW5jdGlvbiB1c2VIb3RrZXlzKGtleXMsIGNhbGxiYWNrLCBvcHRpb25zLCBkZXBlbmRlbmNpZXMpIHtcbiAgdmFyIHJlZiA9IHVzZVJlZihudWxsKTtcbiAgdmFyIF91c2VSZWYgPSB1c2VSZWYobmV3IFNldCgpKSxcbiAgICBwcmVzc2VkRG93bktleXMgPSBfdXNlUmVmLmN1cnJlbnQ7XG4gIHZhciBfb3B0aW9ucyA9ICEob3B0aW9ucyBpbnN0YW5jZW9mIEFycmF5KSA/IG9wdGlvbnMgOiAhKGRlcGVuZGVuY2llcyBpbnN0YW5jZW9mIEFycmF5KSA/IGRlcGVuZGVuY2llcyA6IHVuZGVmaW5lZDtcbiAgdmFyIF9kZXBzID0gb3B0aW9ucyBpbnN0YW5jZW9mIEFycmF5ID8gb3B0aW9ucyA6IGRlcGVuZGVuY2llcyBpbnN0YW5jZW9mIEFycmF5ID8gZGVwZW5kZW5jaWVzIDogW107XG4gIHZhciBjYiA9IHVzZUNhbGxiYWNrKGNhbGxiYWNrLCBbXS5jb25jYXQoX2RlcHMpKTtcbiAgdmFyIG1lbW9pc2VkT3B0aW9ucyA9IHVzZURlZXBFcXVhbE1lbW8oX29wdGlvbnMpO1xuICB2YXIgX3VzZUhvdGtleXNDb250ZXh0ID0gdXNlSG90a2V5c0NvbnRleHQoKSxcbiAgICBlbmFibGVkU2NvcGVzID0gX3VzZUhvdGtleXNDb250ZXh0LmVuYWJsZWRTY29wZXM7XG4gIHZhciBwcm94eSA9IHVzZUJvdW5kSG90a2V5c1Byb3h5KCk7XG4gIHVzZVNhZmVMYXlvdXRFZmZlY3QoZnVuY3Rpb24gKCkge1xuICAgIGlmICgobWVtb2lzZWRPcHRpb25zID09IG51bGwgPyB2b2lkIDAgOiBtZW1vaXNlZE9wdGlvbnMuZW5hYmxlZCkgPT09IGZhbHNlIHx8ICFpc1Njb3BlQWN0aXZlKGVuYWJsZWRTY29wZXMsIG1lbW9pc2VkT3B0aW9ucyA9PSBudWxsID8gdm9pZCAwIDogbWVtb2lzZWRPcHRpb25zLnNjb3BlcykpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdmFyIGxpc3RlbmVyID0gZnVuY3Rpb24gbGlzdGVuZXIoZSkge1xuICAgICAgdmFyIF9lJHRhcmdldDtcbiAgICAgIGlmIChpc0tleWJvYXJkRXZlbnRUcmlnZ2VyZWRCeUlucHV0KGUpICYmICFpc0hvdGtleUVuYWJsZWRPblRhZyhlLCBtZW1vaXNlZE9wdGlvbnMgPT0gbnVsbCA/IHZvaWQgMCA6IG1lbW9pc2VkT3B0aW9ucy5lbmFibGVPbkZvcm1UYWdzKSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICAvLyBUT0RPOiBTSU5DRSBUSEUgRVZFTlQgSVMgTk9XIEFUVEFDSEVEIFRPIFRIRSBSRUYsIFRIRSBBQ1RJVkUgRUxFTUVOVCBDQU4gTkVWRVIgQkUgSU5TSURFIFRIRSBSRUYuIFRIRSBIT1RLRVkgT05MWSBUUklHR0VSUyBJRiBUSEVcbiAgICAgIC8vIFJFRiBJUyBUSEUgQUNUSVZFIEVMRU1FTlQuIFRISVMgSVMgQSBQUk9CTEVNIFNJTkNFIEZPQ1VTRUQgU1VCIENPTVBPTkVOVFMgV09OVCBUUklHR0VSIFRIRSBIT1RLRVkuXG4gICAgICBpZiAocmVmLmN1cnJlbnQgIT09IG51bGwgJiYgZG9jdW1lbnQuYWN0aXZlRWxlbWVudCAhPT0gcmVmLmN1cnJlbnQgJiYgIXJlZi5jdXJyZW50LmNvbnRhaW5zKGRvY3VtZW50LmFjdGl2ZUVsZW1lbnQpKSB7XG4gICAgICAgIHN0b3BQcm9wYWdhdGlvbihlKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgaWYgKChfZSR0YXJnZXQgPSBlLnRhcmdldCkgIT0gbnVsbCAmJiBfZSR0YXJnZXQuaXNDb250ZW50RWRpdGFibGUgJiYgIShtZW1vaXNlZE9wdGlvbnMgIT0gbnVsbCAmJiBtZW1vaXNlZE9wdGlvbnMuZW5hYmxlT25Db250ZW50RWRpdGFibGUpKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIHBhcnNlS2V5c0hvb2tJbnB1dChrZXlzLCBtZW1vaXNlZE9wdGlvbnMgPT0gbnVsbCA/IHZvaWQgMCA6IG1lbW9pc2VkT3B0aW9ucy5zcGxpdEtleSkuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XG4gICAgICAgIHZhciBfaG90a2V5JGtleXM7XG4gICAgICAgIHZhciBob3RrZXkgPSBwYXJzZUhvdGtleShrZXksIG1lbW9pc2VkT3B0aW9ucyA9PSBudWxsID8gdm9pZCAwIDogbWVtb2lzZWRPcHRpb25zLmNvbWJpbmF0aW9uS2V5KTtcbiAgICAgICAgaWYgKGlzSG90a2V5TWF0Y2hpbmdLZXlib2FyZEV2ZW50KGUsIGhvdGtleSwgcHJlc3NlZERvd25LZXlzKSB8fCAoX2hvdGtleSRrZXlzID0gaG90a2V5LmtleXMpICE9IG51bGwgJiYgX2hvdGtleSRrZXlzLmluY2x1ZGVzKCcqJykpIHtcbiAgICAgICAgICBtYXliZVByZXZlbnREZWZhdWx0KGUsIGhvdGtleSwgbWVtb2lzZWRPcHRpb25zID09IG51bGwgPyB2b2lkIDAgOiBtZW1vaXNlZE9wdGlvbnMucHJldmVudERlZmF1bHQpO1xuICAgICAgICAgIGlmICghaXNIb3RrZXlFbmFibGVkKGUsIGhvdGtleSwgbWVtb2lzZWRPcHRpb25zID09IG51bGwgPyB2b2lkIDAgOiBtZW1vaXNlZE9wdGlvbnMuZW5hYmxlZCkpIHtcbiAgICAgICAgICAgIHN0b3BQcm9wYWdhdGlvbihlKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG4gICAgICAgICAgY2IoZSwgaG90a2V5KTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfTtcbiAgICB2YXIgaGFuZGxlS2V5RG93biA9IGZ1bmN0aW9uIGhhbmRsZUtleURvd24oZXZlbnQpIHtcbiAgICAgIHByZXNzZWREb3duS2V5cy5hZGQoZXZlbnQua2V5LnRvTG93ZXJDYXNlKCkpO1xuICAgICAgaWYgKChtZW1vaXNlZE9wdGlvbnMgPT0gbnVsbCA/IHZvaWQgMCA6IG1lbW9pc2VkT3B0aW9ucy5rZXlkb3duKSA9PT0gdW5kZWZpbmVkICYmIChtZW1vaXNlZE9wdGlvbnMgPT0gbnVsbCA/IHZvaWQgMCA6IG1lbW9pc2VkT3B0aW9ucy5rZXl1cCkgIT09IHRydWUgfHwgbWVtb2lzZWRPcHRpb25zICE9IG51bGwgJiYgbWVtb2lzZWRPcHRpb25zLmtleWRvd24pIHtcbiAgICAgICAgbGlzdGVuZXIoZXZlbnQpO1xuICAgICAgfVxuICAgIH07XG4gICAgdmFyIGhhbmRsZUtleVVwID0gZnVuY3Rpb24gaGFuZGxlS2V5VXAoZXZlbnQpIHtcbiAgICAgIGlmIChldmVudC5rZXkudG9Mb3dlckNhc2UoKSAhPT0gJ21ldGEnKSB7XG4gICAgICAgIHByZXNzZWREb3duS2V5c1tcImRlbGV0ZVwiXShldmVudC5rZXkudG9Mb3dlckNhc2UoKSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBPbiBtYWNPUyBwcmVzc2luZyBkb3duIHRoZSBtZXRhIGtleSBwcmV2ZW50cyB0cmlnZ2VyaW5nIHRoZSBrZXl1cCBldmVudCBmb3IgYW55IG90aGVyIGtleSBodHRwczovL3N0YWNrb3ZlcmZsb3cuY29tL2EvNTcxNTMzMDAvNzM1MjI2LlxuICAgICAgICBwcmVzc2VkRG93bktleXMuY2xlYXIoKTtcbiAgICAgIH1cbiAgICAgIGlmIChtZW1vaXNlZE9wdGlvbnMgIT0gbnVsbCAmJiBtZW1vaXNlZE9wdGlvbnMua2V5dXApIHtcbiAgICAgICAgbGlzdGVuZXIoZXZlbnQpO1xuICAgICAgfVxuICAgIH07XG4gICAgLy8gQHRzLWlnbm9yZVxuICAgIChyZWYuY3VycmVudCB8fCBkb2N1bWVudCkuYWRkRXZlbnRMaXN0ZW5lcigna2V5dXAnLCBoYW5kbGVLZXlVcCk7XG4gICAgLy8gQHRzLWlnbm9yZVxuICAgIChyZWYuY3VycmVudCB8fCBkb2N1bWVudCkuYWRkRXZlbnRMaXN0ZW5lcigna2V5ZG93bicsIGhhbmRsZUtleURvd24pO1xuICAgIGlmIChwcm94eSkge1xuICAgICAgcGFyc2VLZXlzSG9va0lucHV0KGtleXMsIG1lbW9pc2VkT3B0aW9ucyA9PSBudWxsID8gdm9pZCAwIDogbWVtb2lzZWRPcHRpb25zLnNwbGl0S2V5KS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgICAgcmV0dXJuIHByb3h5LmFkZEhvdGtleShwYXJzZUhvdGtleShrZXksIG1lbW9pc2VkT3B0aW9ucyA9PSBudWxsID8gdm9pZCAwIDogbWVtb2lzZWRPcHRpb25zLmNvbWJpbmF0aW9uS2V5KSk7XG4gICAgICB9KTtcbiAgICB9XG4gICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgIC8vIEB0cy1pZ25vcmVcbiAgICAgIChyZWYuY3VycmVudCB8fCBkb2N1bWVudCkucmVtb3ZlRXZlbnRMaXN0ZW5lcigna2V5dXAnLCBoYW5kbGVLZXlVcCk7XG4gICAgICAvLyBAdHMtaWdub3JlXG4gICAgICAocmVmLmN1cnJlbnQgfHwgZG9jdW1lbnQpLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2tleWRvd24nLCBoYW5kbGVLZXlEb3duKTtcbiAgICAgIGlmIChwcm94eSkge1xuICAgICAgICBwYXJzZUtleXNIb29rSW5wdXQoa2V5cywgbWVtb2lzZWRPcHRpb25zID09IG51bGwgPyB2b2lkIDAgOiBtZW1vaXNlZE9wdGlvbnMuc3BsaXRLZXkpLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xuICAgICAgICAgIHJldHVybiBwcm94eS5yZW1vdmVIb3RrZXkocGFyc2VIb3RrZXkoa2V5LCBtZW1vaXNlZE9wdGlvbnMgPT0gbnVsbCA/IHZvaWQgMCA6IG1lbW9pc2VkT3B0aW9ucy5jb21iaW5hdGlvbktleSkpO1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9O1xuICB9LCBba2V5cywgY2IsIG1lbW9pc2VkT3B0aW9ucywgZW5hYmxlZFNjb3Blc10pO1xuICByZXR1cm4gcmVmO1xufVxuXG52YXIgY3VycmVudGx5UHJlc3NlZEtleXMgPSAvKiNfX1BVUkVfXyovbmV3IFNldCgpO1xuZnVuY3Rpb24gaXNIb3RrZXlQcmVzc2VkKGtleSwgc3BsaXRLZXkpIHtcbiAgaWYgKHNwbGl0S2V5ID09PSB2b2lkIDApIHtcbiAgICBzcGxpdEtleSA9ICcsJztcbiAgfVxuICB2YXIgaG90a2V5QXJyYXkgPSBBcnJheS5pc0FycmF5KGtleSkgPyBrZXkgOiBrZXkuc3BsaXQoc3BsaXRLZXkpO1xuICByZXR1cm4gaG90a2V5QXJyYXkuZXZlcnkoZnVuY3Rpb24gKGhvdGtleSkge1xuICAgIHZhciBwYXJzZWRIb3RrZXkgPSBwYXJzZUhvdGtleShob3RrZXkpO1xuICAgIGZvciAodmFyIF9pdGVyYXRvciA9IF9jcmVhdGVGb3JPZkl0ZXJhdG9ySGVscGVyTG9vc2UoY3VycmVudGx5UHJlc3NlZEtleXMpLCBfc3RlcDsgIShfc3RlcCA9IF9pdGVyYXRvcigpKS5kb25lOykge1xuICAgICAgdmFyIHByZXNzZWRIb3RrZXkgPSBfc3RlcC52YWx1ZTtcbiAgICAgIGlmIChkZWVwRXF1YWwocGFyc2VkSG90a2V5LCBwcmVzc2VkSG90a2V5KSkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cbiAgICB9XG4gIH0pO1xufVxuZnVuY3Rpb24gcHVzaFRvQ3VycmVudGx5UHJlc3NlZEtleXMoa2V5KSB7XG4gIHZhciBob3RrZXlBcnJheSA9IEFycmF5LmlzQXJyYXkoa2V5KSA/IGtleSA6IFtrZXldO1xuICBob3RrZXlBcnJheS5mb3JFYWNoKGZ1bmN0aW9uIChob3RrZXkpIHtcbiAgICByZXR1cm4gY3VycmVudGx5UHJlc3NlZEtleXMuYWRkKHBhcnNlSG90a2V5KGhvdGtleSkpO1xuICB9KTtcbn1cbmZ1bmN0aW9uIHJlbW92ZUZyb21DdXJyZW50bHlQcmVzc2VkS2V5cyhrZXkpIHtcbiAgdmFyIGhvdGtleUFycmF5ID0gQXJyYXkuaXNBcnJheShrZXkpID8ga2V5IDogW2tleV07XG4gIGhvdGtleUFycmF5LmZvckVhY2goZnVuY3Rpb24gKGhvdGtleSkge1xuICAgIHZhciBwYXJzZWRIb3RrZXkgPSBwYXJzZUhvdGtleShob3RrZXkpO1xuICAgIGZvciAodmFyIF9pdGVyYXRvcjIgPSBfY3JlYXRlRm9yT2ZJdGVyYXRvckhlbHBlckxvb3NlKGN1cnJlbnRseVByZXNzZWRLZXlzKSwgX3N0ZXAyOyAhKF9zdGVwMiA9IF9pdGVyYXRvcjIoKSkuZG9uZTspIHtcbiAgICAgIHZhciBfcHJlc3NlZEhvdGtleSRrZXlzO1xuICAgICAgdmFyIHByZXNzZWRIb3RrZXkgPSBfc3RlcDIudmFsdWU7XG4gICAgICBpZiAoKF9wcmVzc2VkSG90a2V5JGtleXMgPSBwcmVzc2VkSG90a2V5LmtleXMpICE9IG51bGwgJiYgX3ByZXNzZWRIb3RrZXkka2V5cy5ldmVyeShmdW5jdGlvbiAoa2V5KSB7XG4gICAgICAgIHZhciBfcGFyc2VkSG90a2V5JGtleXM7XG4gICAgICAgIHJldHVybiAoX3BhcnNlZEhvdGtleSRrZXlzID0gcGFyc2VkSG90a2V5LmtleXMpID09IG51bGwgPyB2b2lkIDAgOiBfcGFyc2VkSG90a2V5JGtleXMuaW5jbHVkZXMoa2V5KTtcbiAgICAgIH0pKSB7XG4gICAgICAgIGN1cnJlbnRseVByZXNzZWRLZXlzW1wiZGVsZXRlXCJdKHByZXNzZWRIb3RrZXkpO1xuICAgICAgfVxuICAgIH1cbiAgfSk7XG59XG4oZnVuY3Rpb24gKCkge1xuICBpZiAodHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcignRE9NQ29udGVudExvYWRlZCcsIGZ1bmN0aW9uICgpIHtcbiAgICAgIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ2tleWRvd24nLCBmdW5jdGlvbiAoZSkge1xuICAgICAgICBwdXNoVG9DdXJyZW50bHlQcmVzc2VkS2V5cyhlLmtleSk7XG4gICAgICB9KTtcbiAgICAgIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ2tleXVwJywgZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgcmVtb3ZlRnJvbUN1cnJlbnRseVByZXNzZWRLZXlzKGUua2V5KTtcbiAgICAgIH0pO1xuICAgIH0pO1xuICB9XG59KSgpO1xuXG5leHBvcnQgeyBIb3RrZXlzUHJvdmlkZXIsIGlzSG90a2V5UHJlc3NlZCwgdXNlSG90a2V5cywgdXNlSG90a2V5c0NvbnRleHQgfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXJlYWN0LWhvdGtleXMtaG9vay5lc20uanMubWFwXG4iXSwibmFtZXMiOlsidXNlQ29udGV4dCIsImNyZWF0ZUNvbnRleHQiLCJ1c2VTdGF0ZSIsInVzZU1lbW8iLCJ1c2VSZWYiLCJ1c2VDYWxsYmFjayIsInVzZUxheW91dEVmZmVjdCIsInVzZUVmZmVjdCIsImpzeCIsIl9leHRlbmRzIiwiT2JqZWN0IiwiYXNzaWduIiwiYmluZCIsInRhcmdldCIsImkiLCJhcmd1bWVudHMiLCJsZW5ndGgiLCJzb3VyY2UiLCJrZXkiLCJwcm90b3R5cGUiLCJoYXNPd25Qcm9wZXJ0eSIsImNhbGwiLCJhcHBseSIsIl91bnN1cHBvcnRlZEl0ZXJhYmxlVG9BcnJheSIsIm8iLCJtaW5MZW4iLCJfYXJyYXlMaWtlVG9BcnJheSIsIm4iLCJ0b1N0cmluZyIsInNsaWNlIiwiY29uc3RydWN0b3IiLCJuYW1lIiwiQXJyYXkiLCJmcm9tIiwidGVzdCIsImFyciIsImxlbiIsImFycjIiLCJfY3JlYXRlRm9yT2ZJdGVyYXRvckhlbHBlckxvb3NlIiwiYWxsb3dBcnJheUxpa2UiLCJpdCIsIlN5bWJvbCIsIml0ZXJhdG9yIiwibmV4dCIsImlzQXJyYXkiLCJkb25lIiwidmFsdWUiLCJUeXBlRXJyb3IiLCJyZXNlcnZlZE1vZGlmaWVyS2V5d29yZHMiLCJtYXBwZWRLZXlzIiwiZXNjIiwibGVmdCIsInVwIiwicmlnaHQiLCJkb3duIiwicGFyc2VLZXlzSG9va0lucHV0Iiwia2V5cyIsInNwbGl0S2V5Iiwic3BsaXQiLCJwYXJzZUhvdGtleSIsImhvdGtleSIsImNvbWJpbmF0aW9uS2V5IiwidG9Mb2NhbGVMb3dlckNhc2UiLCJtYXAiLCJrIiwidHJpbSIsIm1vZGlmaWVycyIsImFsdCIsImluY2x1ZGVzIiwiY3RybCIsInNoaWZ0IiwibWV0YSIsIm1vZCIsInNpbmdsZUNoYXJLZXlzIiwiZmlsdGVyIiwibWF5YmVQcmV2ZW50RGVmYXVsdCIsImUiLCJwcmV2ZW50RGVmYXVsdCIsImlzSG90a2V5RW5hYmxlZCIsImVuYWJsZWQiLCJ1bmRlZmluZWQiLCJpc0tleWJvYXJkRXZlbnRUcmlnZ2VyZWRCeUlucHV0IiwiZXYiLCJpc0hvdGtleUVuYWJsZWRPblRhZyIsIl9yZWYiLCJlbmFibGVkT25UYWdzIiwidGFyZ2V0VGFnTmFtZSIsInRhZ05hbWUiLCJCb29sZWFuIiwic29tZSIsInRhZyIsInRvTG93ZXJDYXNlIiwiaXNTY29wZUFjdGl2ZSIsImFjdGl2ZVNjb3BlcyIsInNjb3BlcyIsImNvbnNvbGUiLCJ3YXJuIiwic2NvcGUiLCJpc0hvdGtleU1hdGNoaW5nS2V5Ym9hcmRFdmVudCIsInByZXNzZWREb3duS2V5cyIsImFsdEtleSIsImN0cmxLZXkiLCJtZXRhS2V5Iiwic2hpZnRLZXkiLCJwcmVzc2VkS2V5VXBwZXJjYXNlIiwiY29kZSIsImtleUNvZGUiLCJyZXBsYWNlIiwicHJlc3NlZEtleSIsImV2ZXJ5IiwiaGFzIiwiQm91bmRIb3RrZXlzUHJveHlQcm92aWRlciIsInVzZUJvdW5kSG90a2V5c1Byb3h5IiwiQm91bmRIb3RrZXlzUHJveHlQcm92aWRlclByb3ZpZGVyIiwiYWRkSG90a2V5IiwicmVtb3ZlSG90a2V5IiwiY2hpbGRyZW4iLCJQcm92aWRlciIsIkhvdGtleXNDb250ZXh0IiwiaG90a2V5cyIsImVuYWJsZWRTY29wZXMiLCJ0b2dnbGVTY29wZSIsImVuYWJsZVNjb3BlIiwiZGlzYWJsZVNjb3BlIiwidXNlSG90a2V5c0NvbnRleHQiLCJIb3RrZXlzUHJvdmlkZXIiLCJfcmVmJGluaXRpYWxseUFjdGl2ZVMiLCJpbml0aWFsbHlBY3RpdmVTY29wZXMiLCJfdXNlU3RhdGUiLCJpbnRlcm5hbEFjdGl2ZVNjb3BlcyIsInNldEludGVybmFsQWN0aXZlU2NvcGVzIiwiX3VzZVN0YXRlMiIsImJvdW5kSG90a2V5cyIsInNldEJvdW5kSG90a2V5cyIsImlzQWxsQWN0aXZlIiwiU2V0IiwiY29uY2F0IiwicyIsImFkZEJvdW5kSG90a2V5IiwicmVtb3ZlQm91bmRIb3RrZXkiLCJoIiwiZGVlcEVxdWFsIiwieCIsInkiLCJyZWR1Y2UiLCJpc0VxdWFsIiwidXNlRGVlcEVxdWFsTWVtbyIsInJlZiIsImN1cnJlbnQiLCJzdG9wUHJvcGFnYXRpb24iLCJzdG9wSW1tZWRpYXRlUHJvcGFnYXRpb24iLCJ1c2VTYWZlTGF5b3V0RWZmZWN0IiwidXNlSG90a2V5cyIsImNhbGxiYWNrIiwib3B0aW9ucyIsImRlcGVuZGVuY2llcyIsIl91c2VSZWYiLCJfb3B0aW9ucyIsIl9kZXBzIiwiY2IiLCJtZW1vaXNlZE9wdGlvbnMiLCJfdXNlSG90a2V5c0NvbnRleHQiLCJwcm94eSIsImxpc3RlbmVyIiwiX2UkdGFyZ2V0IiwiZW5hYmxlT25Gb3JtVGFncyIsImRvY3VtZW50IiwiYWN0aXZlRWxlbWVudCIsImNvbnRhaW5zIiwiaXNDb250ZW50RWRpdGFibGUiLCJlbmFibGVPbkNvbnRlbnRFZGl0YWJsZSIsImZvckVhY2giLCJfaG90a2V5JGtleXMiLCJoYW5kbGVLZXlEb3duIiwiZXZlbnQiLCJhZGQiLCJrZXlkb3duIiwia2V5dXAiLCJoYW5kbGVLZXlVcCIsImNsZWFyIiwiYWRkRXZlbnRMaXN0ZW5lciIsInJlbW92ZUV2ZW50TGlzdGVuZXIiLCJjdXJyZW50bHlQcmVzc2VkS2V5cyIsImlzSG90a2V5UHJlc3NlZCIsImhvdGtleUFycmF5IiwicGFyc2VkSG90a2V5IiwiX2l0ZXJhdG9yIiwiX3N0ZXAiLCJwcmVzc2VkSG90a2V5IiwicHVzaFRvQ3VycmVudGx5UHJlc3NlZEtleXMiLCJyZW1vdmVGcm9tQ3VycmVudGx5UHJlc3NlZEtleXMiLCJfaXRlcmF0b3IyIiwiX3N0ZXAyIiwiX3ByZXNzZWRIb3RrZXkka2V5cyIsIl9wYXJzZWRIb3RrZXkka2V5cyIsIndpbmRvdyJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/.pnpm/react-hotkeys-hook@4.0.4_react-dom@18.2.0_react@18.2.0/node_modules/react-hotkeys-hook/dist/react-hotkeys-hook.esm.js\n");

/***/ })

};
;